<div class="modal" role="dialog" aria-modal="true" aria-labelledby="newDeckTitle" style="position:fixed; inset:0; z-index:1000; display:flex; align-items:flex-start; justify-content:center; padding:1rem; overflow:auto;">
  <div class="modal-backdrop" style="position:fixed; inset:0; background:rgba(0,0,0,.6);"></div>
  <div class="modal-content" style="position:relative; max-width:720px; width:clamp(320px, 90vw, 720px); background:#0f1115; border:1px solid var(--border); border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,.5); padding:1rem; max-height:min(92vh, 100%); overflow:auto; -webkit-overflow-scrolling:touch;">
    <div class="modal-header">
  <h3 id="newDeckTitle">Build a New Deck</h3>
    </div>
    {% if error %}
    <div class="error" role="alert" style="margin:.35rem 0 .5rem 0;">{{ error }}</div>
    {% endif %}
  <form hx-post="/build/new" hx-target="#wizard" hx-swap="innerHTML" hx-on="htmx:afterRequest: (function(evt){ try{ if(evt && evt.detail && evt.detail.elt === this){ var m=this.closest('.modal'); if(m){ m.remove(); } } }catch(_){} }).call(this, event)" autocomplete="off">
      <fieldset>
        <legend>Basics</legend>
  <div class="basics-grid" style="display:grid; grid-template-columns: 2fr 1fr; gap:1rem; align-items:start;">
          <div>
            <label style="display:block; margin-bottom:.5rem;">
              <span class="muted">Optional name (used for file names)</span>
              <input type="text" name="name" placeholder="e.g., Inti Discard Tempo" autocomplete="off" autocapitalize="off" spellcheck="false" />
            </label>
            <label style="display:block; margin-bottom:.5rem;">
              <span>Commander</span>
    <input type="text" name="commander" required placeholder="Type a commander name" value="{{ form.commander if form else '' }}" autofocus autocomplete="off" autocapitalize="off" spellcheck="false"
      role="combobox" aria-autocomplete="list" aria-controls="newdeck-candidates"
      hx-get="/build/new/candidates" hx-trigger="input changed delay:150ms" hx-target="#newdeck-candidates" hx-sync="this:replace" />
            </label>
            <small class="muted" style="display:block; margin-top:.25rem;">Start typing to see matches, then select one to load themes.</small>
            <div id="newdeck-candidates" class="muted" style="font-size:12px; min-height:1.1em;"></div>
          </div>
          <div id="newdeck-commander-slot" class="muted" style="max-width:230px;">
            <em style="font-size:12px;">Pick a commander to preview here.</em>
          </div>
        </div>
      </fieldset>
      <fieldset>
        <legend>Themes</legend>
        <div id="newdeck-tags-slot" class="muted">
          <em>Select a commander to see theme recommendations and choices.</em>
          <input type="hidden" name="primary_tag" />
          <input type="hidden" name="secondary_tag" />
          <input type="hidden" name="tertiary_tag" />
          <input type="hidden" name="tag_mode" value="AND" />
        </div>
  <div id="newdeck-multicopy-slot" class="muted" style="margin-top:.5rem; min-height:1rem;"></div>
        <div style="margin-top:.5rem;" id="newdeck-bracket-slot">
          <label>Bracket
            <select name="bracket">
              {% for b in brackets %}
                {% if not gc_commander or b.level >= 3 %}
                <option value="{{ b.level }}" {% if (form and form.bracket and form.bracket == b.level) or (not form and b.level == 3) %}selected{% endif %}>Bracket {{ b.level }}: {{ b.name }}</option>
                {% endif %}
              {% endfor %}
            </select>
          </label>
        </div>
      </fieldset>
      <fieldset>
        <legend>Preferences</legend>
        <label title="When enabled, the builder will try to auto-complete missing combo partners near the end of the build (respecting owned-only and locks).">
          <input type="checkbox" name="prefer_combos" id="pref-combos-chk" /> Prioritize combos (auto-complete partners)
        </label>
        <div style="margin-top:.35rem;"></div>
        <label title="When enabled, include a Multi-Copy package for matching archetypes (e.g., tokens/tribal).">
          <input type="checkbox" name="enable_multicopy" id="pref-mc-chk" /> Enable Multi-Copy package
        </label>
        <div id="pref-combos-config" style="margin-top:.5rem; padding:.5rem; border:1px solid var(--border); border-radius:8px; display:none;">
          <div style="display:flex; gap:1rem; align-items:center; flex-wrap:wrap;">
            <label>
              <span>How many combos?</span>
              <input type="number" name="combo_count" min="0" max="10" step="1" value="{{ form.combo_count if form and form.combo_count is not none else 2 }}" style="width:6rem; margin-left:.5rem;" />
            </label>
            <div>
              <div class="muted" style="font-size:12px; margin-bottom:.25rem;">Balance of early vs late-game</div>
              <label style="display:inline-flex; align-items:center; gap:.25rem; margin-right:.5rem;">
                <input type="radio" name="combo_balance" value="early" {% if form and form.combo_balance == 'early' %}checked{% endif %}/> Early
              </label>
              <label style="display:inline-flex; align-items:center; gap:.25rem; margin-right:.5rem;">
                <input type="radio" name="combo_balance" value="late" {% if form and form.combo_balance == 'late' %}checked{% endif %}/> Late
              </label>
              <label style="display:inline-flex; align-items:center; gap:.25rem;">
                <input type="radio" name="combo_balance" value="mix" {% if not form or (form and (not form.combo_balance or form.combo_balance == 'mix')) %}checked{% endif %}/> Mix
              </label>
            </div>
          </div>
        </div>
      </fieldset>
      <details style="margin-top:.5rem;">
        <summary>Advanced options (ideals)</summary>
        <div style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:.5rem; margin-top:.5rem;">
          {% for key, label in labels.items() %}
          <label>{{ label }}
            <input type="number" name="{{ key }}" value="{{ defaults[key] }}" min="0" />
          </label>
          {% endfor %}
        </div>
        {% if allow_must_haves %}
        <div style="margin-top:1rem;">
          <label style="display:block;">
            <span class="muted">Cards to exclude (one per line)</span>
            <textarea name="exclude_cards" id="exclude_cards_textarea" placeholder="Sol Ring&#10;Rhystic Study&#10;Smothering Tithe" 
              style="width:100%; min-height:60px; resize:vertical; font-family:monospace; font-size:12px;"
              autocomplete="off" autocapitalize="off" spellcheck="false">{{ form.exclude_cards if form and form.exclude_cards else '' }}</textarea>
          </label>
          <div style="display:flex; align-items:center; gap:.5rem; margin-top:.5rem;">
            <label for="exclude_file_upload" class="btn" style="cursor:pointer; font-size:12px; padding:.25rem .5rem;">
              ðŸ“„ Upload .txt file
            </label>
            <input type="file" id="exclude_file_upload" accept=".txt" style="display:none;" 
              onchange="handleExcludeFileUpload(this)" />
            <small class="muted">or enter cards manually above</small>
          </div>
          <small class="muted" style="display:block; margin-top:.25rem;">
            Enter one card name per line. Names will be fuzzy-matched against the card database.
          </small>
          <div id="exclude_validation" style="margin-top:.5rem; font-size:12px;"></div>
        </div>
        {% endif %}
      </details>
      <div class="modal-footer" style="display:flex; gap:.5rem; justify-content:flex-end; margin-top:1rem;">
        <button type="button" class="btn" onclick="this.closest('.modal').remove()">Cancel</button>
        <button type="submit" class="btn-continue">Create</button>
      </div>
    </form>
  </div>
</div>

<script>
  // Handle exclude cards file upload
  function handleExcludeFileUpload(input) {
    if (input.files && input.files[0]) {
      const file = input.files[0];
      if (!file.name.toLowerCase().endsWith('.txt')) {
        alert('Please select a .txt file');
        input.value = '';
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const textarea = document.getElementById('exclude_cards_textarea');
        const fileContent = e.target.result;
        const newlineRegex = /\r?\n/;
        const lines = fileContent.split(newlineRegex).map(function(line) { return line.trim(); }).filter(function(line) { return line; });
        
        // Merge with existing content (if any)
        const existingContent = textarea.value.trim();
        const existingLines = existingContent ? existingContent.split(newlineRegex).map(function(line) { return line.trim(); }).filter(function(line) { return line; }) : [];
        
        // Combine and deduplicate
        const allLinesSet = new Set([].concat(existingLines).concat(lines));
        const allLines = Array.from(allLinesSet);
        textarea.value = allLines.join('\n');
        
        // Show feedback
        const validation = document.getElementById('exclude_validation');
        if (validation) {
          validation.innerHTML = '<span style="color: #4ade80;">âœ“ Loaded ' + lines.length + ' cards from file</span>';
          setTimeout(function() { validation.innerHTML = ''; }, 3000);
        }
        
        // Clear file input for re-upload
        input.value = '';
      };
      reader.readAsText(file);
    }
  }
  
  // Live validation for exclude cards
  function validateExcludeCards() {
    const textarea = document.getElementById('exclude_cards_textarea');
    const validation = document.getElementById('exclude_validation');
    
    if (!textarea || !validation) return;
    
    const content = textarea.value.trim();
    
    if (!content) {
      validation.innerHTML = '';
      return;
    }
    
    // Show loading state
    validation.innerHTML = '<span style="color: #6b7280;">Validating...</span>';
    
    // Use fetch instead of HTMX for this simple case
    const formData = new FormData();
    formData.append('exclude_cards', content);
    
    fetch('/build/validate/exclude_cards', {
      method: 'POST',
      body: formData
    })
    .then(response => response.json())
    .then(data => {
      if (data.error) {
        validation.innerHTML = '<span style="color: #ef4444;">Error: ' + data.error + '</span>';
        return;
      }
      
      let html = '';
      const count = data.count || 0;
      const limit = data.limit || 15;
      
      if (count === 0) {
        validation.innerHTML = '';
        return;
      }
      
      // Count display
      const countColor = data.over_limit ? '#ef4444' : (count > limit * 0.8 ? '#f59e0b' : '#4ade80');
      html += '<span style="color: ' + countColor + ';">ðŸ“Š ' + count + '/' + limit + ' cards</span>';
      
      // Warnings
      if (data.warnings && data.warnings.length > 0) {
        html += ' <span style="color: #ef4444;">âš  ' + data.warnings[0] + '</span>';
      }
      
      validation.innerHTML = html;
    })
    .catch(error => {
      validation.innerHTML = '<span style="color: #ef4444;">Validation failed</span>';
    });
  }
  
  // Set up live validation on textarea changes
  document.addEventListener('DOMContentLoaded', function() {
    const textarea = document.getElementById('exclude_cards_textarea');
    if (textarea) {
      let validationTimer;
      textarea.addEventListener('input', function() {
        clearTimeout(validationTimer);
        validationTimer = setTimeout(validateExcludeCards, 500); // Debounce 500ms
      });
      
      // Initial validation if there's content
      if (textarea.value.trim()) {
        validateExcludeCards();
      }
    }
  });
  
  // Auto deck name generation on commander change
  (function(){
    try{
      var modal = document.currentScript && document.currentScript.previousElementSibling ? document.currentScript.previousElementSibling.previousElementSibling : document.querySelector('.modal');
      var backdrop = modal ? modal.querySelector('.modal-backdrop') : null;
      if (backdrop){ backdrop.addEventListener('click', function(){ try{ modal.remove(); }catch(_){} }); }
    }catch(_){ }
    var modal = document.currentScript && document.currentScript.previousElementSibling ? document.currentScript.previousElementSibling.previousElementSibling : document.querySelector('.modal');
    // Prevent Enter in text inputs from submitting the form
    try {
      var form = modal ? modal.querySelector('form') : document.querySelector('.modal form');
      if (form){
        // Form-level Enter: if suggestions exist, pick the first by default
        form.addEventListener('keydown', function(e){
          try{
            if (e.key !== 'Enter' || e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return;
            var list = document.getElementById('newdeck-candidates');
            var first = list && list.querySelector('button.candidate-btn');
            if (first){
              e.preventDefault(); e.stopPropagation(); first.click();
            } else {
              // No suggestions: allow normal form submit
            }
          }catch(_){ }
        }, true);
        // Name field: only block Enter if suggestions exist; otherwise allow submit
        var nameEl = form.querySelector('input[name="name"]');
        if (nameEl){
          nameEl.addEventListener('keydown', function(e){
            if (e.key !== 'Enter') return;
            try{
              var list = document.getElementById('newdeck-candidates');
              var hasBtns = !!(list && list.querySelector('button.candidate-btn'));
              if (hasBtns){ e.preventDefault(); e.stopPropagation(); }
            }catch(_){ }
          });
        }
        // In commander field, Enter picks the first candidate (if any) without closing the modal
        var cmdEl = form.querySelector('input[name=\"commander\"]');
        if (cmdEl){
          function handleEnterNav(e){
            // Enter selects the highlighted (or first) suggestion
            var list = document.getElementById('newdeck-candidates');
            var btns = list ? Array.prototype.slice.call(list.querySelectorAll('button.candidate-btn')) : [];
            var getActiveIndex = function(){ return btns.findIndex(function(b){ return b.classList.contains('active'); }); };
            if (!btns.length) return; // nothing to do, but we've already prevented default
            // Skip if a request is in-flight to avoid fighting with swap timing
            try{ if (cmdEl.matches('.htmx-request') || list.matches('.htmx-request')) return; }catch(_){ }
            if (e.key === 'Enter'){
              var idx = getActiveIndex();
              var target = btns[(idx >= 0 ? idx : 0)];
              if (target) { target.click(); }
            }
          }
          // Capture keydown early to prevent submit on Enter (arrows left to default behavior)
          cmdEl.addEventListener('keydown', function(e){
            if (e.key === 'Enter'){
              var list = document.getElementById('newdeck-candidates');
              var hasBtns = !!(list && list.querySelector('button.candidate-btn'));
              if (hasBtns){
                e.preventDefault();
                e.stopPropagation();
                handleEnterNav(e);
              }
            }
          }, true);
          // Defensive: also block Enter on keyup (in case a browser tries to submit on keyup)
          cmdEl.addEventListener('keyup', function(e){ if (e.key === 'Enter'){ e.preventDefault(); e.stopPropagation(); } });
      // Global fallback: capture keydown at the document level so Enter never slips through when the commander input is focused
          document.addEventListener('keydown', function(e){
            try{
              if (document.activeElement !== cmdEl) return;
        if (e.key !== 'Enter') return;
              var list = document.getElementById('newdeck-candidates');
              var hasBtns = !!(list && list.querySelector('button.candidate-btn'));
              if (!hasBtns) return;
              e.preventDefault();
              e.stopPropagation();
              handleEnterNav(e);
            }catch(_){ }
          }, true);
          // Reset candidate highlight when the list updates
          document.body.addEventListener('htmx:afterSwap', function(ev){
            try {
              var tgt = ev && ev.detail && ev.detail.target ? ev.detail.target : null;
              if (!tgt) return;
              if (tgt.id === 'newdeck-candidates'){
                var first = tgt.querySelector('button.candidate-btn');
                if (first){
                  // Clear any lingering active classes, then set the first as active for immediate Enter selection
                  tgt.querySelectorAll('button.candidate-btn').forEach(function(b){ b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
                  first.classList.add('active');
                  first.setAttribute('aria-selected','true');
                  try{ cmdEl.setAttribute('aria-activedescendant', first.id || ''); }catch(_){ }
                }
              }
            } catch(_){}
          });
        }
      }
    } catch(_){ }
    // Close on Escape
    function closeModal(){ try{ var m = document.querySelector('.modal'); if(m){ m.remove(); document.removeEventListener('keydown', onKey); } }catch(_){} }
    function onKey(e){ if (e.key === 'Escape'){ e.preventDefault(); closeModal(); } }
    document.addEventListener('keydown', onKey);
  })();

  // Toggle combos config visibility based on checkbox
  (function(){
    try {
      var form = document.querySelector('.modal form');
      var chk = form && form.querySelector('#pref-combos-chk');
      var box = form && form.querySelector('#pref-combos-config');
      if (!chk || !box) return;
      function sync(){ box.style.display = chk.checked ? 'block' : 'none'; }
      chk.addEventListener('change', sync);
      // Initial state
      sync();
    } catch(_){}
  })();

  // Integrated Multi-Copy: fetch suggestions once commander + tags are present
  (function(){
    function fetchMulti(){
      try{
        var slot = document.getElementById('newdeck-multicopy-slot');
        var form = document.querySelector('.modal form');
        if (!slot || !form) return;
        var enable = form.querySelector('#pref-mc-chk');
        if (!enable || !enable.checked){ slot.innerHTML = ''; return; }
        var cmd = form.querySelector('input[name="commander"]').value.trim();
        var p = form.querySelector('input[name="primary_tag"]').value.trim();
        var s = form.querySelector('input[name="secondary_tag"]').value.trim();
        var t = form.querySelector('input[name="tertiary_tag"]').value.trim();
        var mode = form.querySelector('input[name="tag_mode"]').value.trim() || 'AND';
        if (!cmd) { slot.innerHTML = ''; return; }
        // Only fetch if at least one tag is present (to avoid noise)
        if (!(p || s || t)) { slot.innerHTML = ''; return; }
        var params = new URLSearchParams({ commander: cmd, tag_mode: mode });
        if (p) params.append('primary_tag', p); if (s) params.append('secondary_tag', s); if (t) params.append('tertiary_tag', t);
        fetch('/build/new/multicopy?' + params.toString(), { headers: { 'HX-Request': 'true' } })
          .then(function(r){ return r.text(); })
          .then(function(html){ slot.innerHTML = html; })
          .catch(function(){ slot.innerHTML = ''; });
      }catch(_){ }
    }
    // Listen for OOB updates to the tags slot to trigger fetch
    document.body.addEventListener('htmx:afterSwap', function(ev){
      try{
        var tgt = ev && ev.detail && ev.detail.target ? ev.detail.target : null;
        if (tgt && tgt.id === 'newdeck-tags-slot'){ fetchMulti(); }
      }catch(_){ }
    });
  // Respond to explicit tag-change signal from the tags partial
  try{ document.addEventListener('newdeck:tagsChanged', fetchMulti); }catch(_){ }
    // Also debounce on commander input changes
    try{
      var cmdEl = document.querySelector('.modal form input[name="commander"]');
      var timer;
      if (cmdEl){ cmdEl.addEventListener('input', function(){ clearTimeout(timer); timer = setTimeout(fetchMulti, 300); }); }
    }catch(_){ }
    // React to preference toggle
    try{
      var mcChk = document.querySelector('.modal form #pref-mc-chk');
      if (mcChk){ mcChk.addEventListener('change', fetchMulti); }
    }catch(_){ }
  })();
</script>

<style>
/* Modal responsive tweaks (scoped) */
@media (max-width: 720px){
  .modal .basics-grid{ grid-template-columns: 1fr !important; }
  #newdeck-commander-slot{ max-width: 100% !important; }
  #newdeck-commander-slot aside.card-preview{ max-width: 100% !important; }
  #newdeck-commander-slot img{ width: 100% !important; max-width: 260px; height: auto; margin: 0 auto; display: block; }
  .modal .modal-content{ width: min(95vw, 560px) !important; }
}
</style>
